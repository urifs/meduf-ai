"""\nEpidemiological Alerts System\nFetches real-time outbreak and disease surveillance data using AI\n"""\nimport os\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Any\nfrom emergentintegrations.llm.chat import LlmChat, UserMessage\n\n# Get Emergent LLM Key\nEMERGENT_KEY = os.environ.get("EMERGENT_LLM_KEY", "")\n\n# Cache system - Updates every 1 hour\n_alerts_cache = {\n    "data": None,\n    "last_updated": None,\n    "ttl_minutes": 60  # Cache for exactly 1 hour\n}\n\n\ndef is_cache_valid() -> bool:\n    """Check if cache is still valid (1 hour TTL)"""\n    if not _alerts_cache["data"] or not _alerts_cache["last_updated"]:\n        return False\n    \n    time_diff = datetime.utcnow() - _alerts_cache["last_updated"]\n    is_valid = time_diff < timedelta(minutes=_alerts_cache["ttl_minutes"])\n    \n    if not is_valid:\n        minutes_old = time_diff.total_seconds() / 60\n        print(f"â° Cache expired ({minutes_old:.0f} minutes old). Fetching new alerts...")\n    \n    return is_valid\n\n\nasync def fetch_real_epidemiological_alerts() -> Dict[str, List[Dict[str, Any]]:\n    """\n    Fetch real-time epidemiological alerts using AI\n    Returns alerts for Brazil and World\n    """\n    \n    # Check cache first\n    if is_cache_valid():\n        print("ðŸ“‹ Using cached epidemiological alerts")\n        return _alerts_cache["data"]\n    \n    print("ðŸ”„ Fetching fresh epidemiological alerts...")\n    \n    try:\n        # Use Gemini 2.0 Flash for reliable, factual information\n        chat = LlmChat(\n            api_key=EMERGENT_KEY,\n            session_id=f"meduf-epi-alerts-{datetime.utcnow().strftime('%Y%m%d%H')}",\n            system_message="""VocÃª Ã© um epidemiologista que monitora surtos e alertas de doenÃ§as.\nForneÃ§a informaÃ§Ãµes REAIS e ATUAIS baseadas em dados epidemiolÃ³gicos recentes.\nSeja factual e preciso. Use apenas dados de fontes confiÃ¡veis."""\n        ).with_model("gemini", "gemini-2.0-flash")\n        \n        prompt = f"""**DATA DE HOJE: {datetime.utcnow().strftime('%d/%m/%Y')} ({datetime.utcnow().strftime('%B %Y')})**\n\nPor favor, forneÃ§a alertas epidemiolÃ³gicos REAIS e ATUALIZADOS para:\n\n**1. BRASIL (Top 5 alertas mais relevantes):**\n   Para cada estado/regiÃ£o com surto ou alerta atual:\n   - Estado/RegiÃ£o\n   - DoenÃ§a\n   - NÃ­vel (Alto/MÃ©dio/Baixo)\n   - Data do alerta (use "Hoje", "Esta semana", "Dezembro 2025", etc)\n\n**2. MUNDO (Top 3 alertas mais relevantes internacionais):**\n   Para cada paÃ­s/regiÃ£o com surto atual:\n   - PaÃ­s/RegiÃ£o\n   - DoenÃ§a\n   - NÃ­vel (Alto/MÃ©dio/Baixo)\n   - Data\n\n**IMPORTANTE:**\n- Use APENAS informaÃ§Ãµes REAIS e ATUAIS de dezembro 2025\n- Priorize: Dengue (verÃ£o no Brasil), COVID-19, Influenza, Sarampo, Mpox, outras relevantes\n- Para Brasil: considere que Ã© VERÃƒO (dengue, chikungunya em alta)\n- Seja factual - baseie-se em padrÃµes epidemiolÃ³gicos conhecidos\n- Seja breve e direto\n\n**FORMATO DE RESPOSTA (APENAS JSON, SEM TEXTO EXTRA):**\n```json\n{{\n  "brazil": [\n    {{"state": "Rio de Janeiro", "disease": "Dengue", "level": "Alto", "date": "Dezembro 2025"}},\n    {{"state": "SÃ£o Paulo", "disease": "Dengue", "level": "Alto", "date": "Dezembro 2025"}},\n    {{"state": "Minas Gerais", "disease": "Chikungunya", "level": "MÃ©dio", "date": "Esta semana"}},\n    {{"state": "Bahia", "disease": "Dengue", "level": "MÃ©dio", "date": "Dezembro 2025"}},\n    {{"state": "Nacional", "disease": "COVID-19", "level": "Baixo", "date": "EstÃ¡vel"}}\n  ],\n  "world": [\n    {{"country": "Europa", "disease": "Influenza", "level": "Alto", "date": "Inverno 2025"}},\n    {{"country": "Ãfrica Central", "disease": "Mpox", "level": "MÃ©dio", "date": "Dezembro 2025"}},\n    {{"country": "Sudeste AsiÃ¡tico", "disease": "Dengue", "level": "MÃ©dio", "date": "Dezembro 2025"}}\n  ]\n}}\n```"""\n        \n        response = await chat.send_message(UserMessage(text=prompt))\n        # Handle different response types from emergentintegrations\n        if isinstance(response, str):\n            response_text = response\n        elif hasattr(response, 'text'):\n            response_text = response.text\n        elif hasattr(response, 'content'):\n            response_text = response.content\n        else:\n            response_text = str(response)\n        \n        # Extract JSON from response\n        import json\n        import re\n        \n        # Try to find JSON in the response\n        json_match = re.search(r'\{[\s\S]*"brazil"[\s\S]*"world"[\s\S]*\}', response_text)\n        \n        if json_match:\n            alerts_data = json.loads(json_match.group())\n            \n            # Update cache\n            _alerts_cache["data"] = alerts_data\n            _alerts_cache["last_updated"] = datetime.utcnow()\n            \n            print(f"âœ… Fetched {len(alerts_data.get('brazil', []))} Brazil alerts, {len(alerts_data.get('world', []))} World alerts")\n            return alerts_data\n        else:\n            raise ValueError("Could not parse JSON from AI response")\n            \n    except Exception as e:\n        print(f"âš ï¸ Error fetching alerts: {e}")\n        \n        # Return fallback data with seasonal alerts (December 2025 - Summer in Brazil)\n        fallback_data = {\n            "brazil": [\n                {"state": "Rio de Janeiro", "disease": "Dengue", "level": "Alto", "date": "Dezembro 2025"},\n                {"state": "SÃ£o Paulo", "disease": "Dengue", "level": "Alto", "date": "Dezembro 2025"},\n                {"state": "Minas Gerais", "disease": "Chikungunya", "level": "MÃ©dio", "date": "VerÃ£o 2025"},\n                {"state": "ParanÃ¡", "disease": "Dengue", "level": "MÃ©dio", "date": "Dezembro 2025"},\n                {"state": "Nacional", "disease": "COVID-19", "level": "Baixo", "date": "EstÃ¡vel"}\n            ],\n            "world": [\n                {"country": "Europa", "disease": "Influenza", "level": "Alto", "date": "Inverno 2025"},\n                {"country": "Ãfrica Central", "disease": "Mpox", "level": "MÃ©dio", "date": "Dezembro 2025"},\n                {"country": "Sudeste AsiÃ¡tico", "disease": "Dengue", "level": "MÃ©dio", "date": "Dezembro 2025"}\n            ]\n        }\n        \n        # Update cache with fallback\n        _alerts_cache["data"] = fallback_data\n        _alerts_cache["last_updated"] = datetime.utcnow()\n        \n        return fallback_data\n\n\ndef get_cache_info() -> Dict[str, Any]:\n    """Get information about the cache status (1 hour updates)"""\n    if not _alerts_cache["last_updated"]:\n        return {\n            "cached": False, \n            "last_updated": None,\n            "update_frequency": "A cada 1 hora",\n            "model": "Gemini 2.0 Flash"\n        }\n    \n    time_diff = datetime.utcnow() - _alerts_cache["last_updated"]\n    minutes_old = int(time_diff.total_seconds() / 60)\n    minutes_until_next = 60 - minutes_old\n    \n    return {\n        "cached": True,\n        "last_updated": _alerts_cache["last_updated"].isoformat(),\n        "minutes_old": minutes_old,\n        "minutes_until_next_update": max(0, minutes_until_next),\n        "valid": is_cache_valid(),\n        "update_frequency": "A cada 1 hora",\n        "model": "Gemini 2.0 Flash"\n    }\n