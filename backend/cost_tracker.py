"""\nCost Tracker for Gemini API Usage\nTracks token usage and calculates costs per consultation\nUses tiktoken for ACCURATE token counting (same as used by LLMs)\n"""\nimport os\nfrom datetime import datetime, timezone\nfrom typing import Dict, Any\nfrom motor.motor_asyncio import AsyncIOMotorClient\nimport tiktoken\n\n# Gemini 2.0 Flash pricing (per 1M tokens)\nGEMINI_INPUT_COST = 0.075  # $0.075 per 1M input tokens (2.0 Flash is cheaper)\nGEMINI_OUTPUT_COST = 0.30  # $0.30 per 1M output tokens (2.0 Flash is cheaper)\n\n# MongoDB connection\nMONGO_URL = os.environ.get("MONGO_URL", "mongodb://localhost:27017")\nclient = AsyncIOMotorClient(MONGO_URL)\ndb_name = os.environ.get("DB_NAME", "meduf_ai")\ndb = client[db_name]\nusage_stats_collection = db.usage_stats\n\n# Initialize tiktoken encoder for accurate token counting\n# Using cl100k_base which is used by GPT-4 and similar models\ntry:\n    _tokenizer = tiktoken.get_encoding("cl100k_base")\nexcept Exception:\n    _tokenizer = None\n    print("âš ï¸ Tiktoken not available, using character-based estimation")\n\n\ndef count_tokens(text: str) -> int:\n    """\n    Count tokens accurately using tiktoken (industry standard)\n    This matches the token counting used by most LLM APIs\n    """\n    if not text:\n        return 0\n    \n    if _tokenizer:\n        try:\n            return len(_tokenizer.encode(text))\n        except Exception as e:\n            print(f"âš ï¸ Tiktoken error: {e}, falling back to estimation")\n    \n    # Fallback: rough estimate (1 token â‰ˆ 4 characters)\n    return len(text) // 4\n\n\ndef calculate_cost(input_tokens: int, output_tokens: int) -> float:\n    """\n    Calculate cost in USD based on token usage\n    """\n    input_cost = (input_tokens / 1_000_000) * GEMINI_INPUT_COST\n    output_cost = (output_tokens / 1_000_000) * GEMINI_OUTPUT_COST\n    return input_cost + output_cost\n\n\nasync def track_usage(\n    user_id: str,\n    consultation_type: str,\n    input_text: str,\n    output_text: str,\n    model: str = "gemini-2.0-flash"\n):\n    """\n    Track API usage and cost for a consultation\n    Uses tiktoken for ACCURATE token counting\n    """\n    try:\n        # Count tokens accurately using tiktoken\n        input_tokens = count_tokens(input_text)\n        output_tokens = count_tokens(output_text)\n        \n        # Calculate cost with REAL token counts\n        cost_usd = calculate_cost(input_tokens, output_tokens)\n        \n        # Create usage record\n        usage_record = {\n            "user_id": user_id,\n            "consultation_type": consultation_type,\n            "model": model,\n            "input_tokens": input_tokens,\n            "output_tokens": output_tokens,\n            "total_tokens": input_tokens + output_tokens,\n            "cost_usd": cost_usd,\n            "timestamp": datetime.now(timezone.utc),\n            "month": datetime.now(timezone.utc).strftime("%Y-%m"),\n            "year": datetime.now(timezone.utc).year\n        }\n        \n        # Save to database\n        await usage_stats_collection.insert_one(usage_record)\n        \n        print(f"ðŸ’° Usage tracked (ACCURATE): {input_tokens + output_tokens} tokens (input: {input_tokens}, output: {output_tokens}), cost: ${cost_usd:.6f}")\n        \n        return usage_record\n        \n    except Exception as e:\n        print(f"âš ï¸ Error tracking usage: {e}")\n        return None\n\n\ndef get_monthly_stats_sync(year: int = None, month: int = None) -> Dict[str, Any]:\n    """\n    Get usage statistics for a specific month (synchronous version)\n    """\n    try:\n        from pymongo import MongoClient\n        \n        # Create sync MongoDB client\n        sync_client = MongoClient(MONGO_URL)\n        sync_db = sync_client[db_name]\n        sync_collection = sync_db.usage_stats\n        \n        # Default to current month\n        if not year or not month:\n            now = datetime.now(timezone.utc)\n            year = now.year\n            month = now.month\n        \n        month_str = f"{year}-{month:02d}"\n        \n        # Aggregate stats\n        pipeline = [\n            {"$match": {"month": month_str}},\n            {\n                "$group": {\n                    "_id": None,\n                    "total_consultations": {"$sum": 1},\n                    "total_tokens": {"$sum": "$total_tokens"},\n                    "total_cost_usd": {"$sum": "$cost_usd"},\n                    "input_tokens": {"$sum": "$input_tokens"},\n                    "output_tokens": {"$sum": "$output_tokens"}\n                }\n            }\n        ]\n        \n        result = list(sync_collection.aggregate(pipeline))\n        sync_client.close()\n        \n        if result:\n            stats = result[0]\n            return {\n                "month": month_str,\n                "total_consultations": stats.get("total_consultations", 0),\n                "total_tokens": stats.get("total_tokens", 0),\n                "total_cost_usd": round(stats.get("total_cost_usd", 0), 4),\n                "input_tokens": stats.get("input_tokens", 0),\n                "output_tokens": stats.get("output_tokens", 0)\n            }\n        else:\n            return {\n                "month": month_str,\n                "total_consultations": 0,\n                "total_tokens": 0,\n                "total_cost_usd": 0.0,\n                "input_tokens": 0,\n                "output_tokens": 0\n            }\n            \n    except Exception as e:\n        print(f"âš ï¸ Error getting monthly stats: {e}")\n        now = datetime.now(timezone.utc)\n        return {\n            "month": f"{now.year}-{now.month:02d}",\n            "total_consultations": 0,\n            "total_tokens": 0,\n            "total_cost_usd": 0.0,\n            "error": str(e)\n        }\n\n\nasync def get_monthly_stats(year: int = None, month: int = None) -> Dict[str, Any]:\n    """\n    Get usage statistics for a specific month (async wrapper)\n    """\n    return get_monthly_stats_sync(year, month)\n\n\ndef get_all_time_stats_sync() -> Dict[str, Any]:\n    """\n    Get all-time usage statistics (synchronous version)\n    """\n    try:\n        from pymongo import MongoClient\n        \n        # Create sync MongoDB client\n        sync_client = MongoClient(MONGO_URL)\n        sync_db = sync_client[db_name]\n        sync_collection = sync_db.usage_stats\n        \n        pipeline = [\n            {\n                "$group": {\n                    "_id": None,\n                    "total_consultations": {"$sum": 1},\n                    "total_tokens": {"$sum": "$total_tokens"},\n                    "total_cost_usd": {"$sum": "$cost_usd"}\n                }\n            }\n        ]\n        \n        result = list(sync_collection.aggregate(pipeline))\n        sync_client.close()\n        \n        if result:\n            stats = result[0]\n            return {\n                "total_consultations": stats.get("total_consultations", 0),\n                "total_tokens": stats.get("total_tokens", 0),\n                "total_cost_usd": round(stats.get("total_cost_usd", 0), 4)\n            }\n        else:\n            return {\n                "total_consultations": 0,\n                "total_tokens": 0,\n                "total_cost_usd": 0.0\n            }\n            \n    except Exception as e:\n        print(f"âš ï¸ Error getting all-time stats: {e}")\n        return {\n            "total_consultations": 0,\n            "total_tokens": 0,\n            "total_cost_usd": 0.0,\n            "error": str(e)\n        }\n\n\nasync def get_all_time_stats() -> Dict[str, Any]:\n    """\n    Get all-time usage statistics (async wrapper)\n    """\n    return get_all_time_stats_sync()\n